%{
#
# Parse.pm
#
# Copyright (C) 2007, 2008 Francesco Salvestrini
#                          Alessandro Massignan
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

use 5.8.0;

use warnings;
use strict;
use diagnostics;

use Choicetool::Autoconfig;
use Choicetool::Base::Trace;
use Choicetool::Base::Debug;
use Choicetool::OS::File;

use Choicetool::Data::Set;
use Choicetool::Data::Stack;

use Choicetool::Widgets::Widget;
use Choicetool::Widgets::Checkbox;
use Choicetool::Widgets::Label;
use Choicetool::Widgets::Listbox;
use Choicetool::Widgets::Menu;
use Choicetool::Widgets::Textbox;
use Choicetool::Widgets::Tooltip;
use Choicetool::Widgets::Window;

use Choicetool::Binder;

BEGIN {
    use Exporter ();
    our ($VERSION, @ISA, @EXPORT);

    @ISA    = qw(Exporter);
    @EXPORT = qw(&parse);
}

#
# XXX FIX ME:
#   remove global variables ASAP
#

my $parsed_string   = "";
my $help_text_parse = 0;
my $help_start      = 0;
my $lineno          = 1;

my $ui_id           = 0;
my $rule_id         = 0;

my $word;
my $mainmenu;
my $type_definition;

sub dtoken ($)
{
    my $string = shift;

    assert(defined($string));

    debug("Found token: " . $string);
}

sub drule ($)
{
    my $string = shift;

    assert(defined($string));

    debug("Get rule: " . $string);
}


%}

%left  'T_AND'
%left  'T_OR'
%left  'T_UNEQUAL'
%left  'T_EQUAL'
%right 'T_NOT'

%start input

%%

input:
     | newlines
{
    drule("input");
}
     ;

newlines: newline
{
    drule("newlines");
}
        | newline newlines
        ;

newline: 'T_EOL'
{
    $lineno++;
    drule("newline");
}
       ;

%%

sub parse_help ($$)
{
    my $stream_ref  = shift;
    my $string_ref  = shift;
    my $ws_length;

    assert(defined($$stream_ref));
    assert(defined($$string_ref));

    while ($$stream_ref =~ s/^([^\n]*)\n//) {
	my $string = $1;

	$lineno++;

	if ($string =~ s/^([ \t]*)$//) {
	    $$string_ref = $$string_ref . "\n";

	} elsif ($string =~ s/^([ \t]+)(.+)$//) {
	    my $ws             = $1;
	    my $text           = $2;
	    my $curr_ws_length = 0;
	    my $tmp            = $ws;

	    for (my $i = 0; $i < length($ws); $i++) {
		my $token = substr($tmp, 0, 1, "");

		if ($token =~ /\ /) {
		    $curr_ws_length++;
		} elsif ($token =~ /\t/) {
		    $curr_ws_length = ($curr_ws_length & ~7) + 8;
		}
	    }

	    if (!defined($ws_length)) {
		$ws_length = $curr_ws_length;
	    }

	    if ($curr_ws_length < $ws_length) {
		$$stream_ref = $1 . $2 . "\n" . $$stream_ref;

		$lineno--;
		last;
	    }

	    if ($curr_ws_length > $ws_length) {
		$text = " " x ($curr_ws_length - $ws_length) . $text;
	    }

	    $$string_ref = $$string_ref . $text . "\n";

	} elsif ($string =~ s/^([^ \t])(.*)$//) {

	    if (defined($2)) {
		$$stream_ref = $2 . "\n" . $$stream_ref;
		$$stream_ref = $1 . $$stream_ref;
	    } else {
		$$stream_ref = $1 . "\n". $$stream_ref;
	    }

	    $lineno--;
	    last;
	} else {
	    bug("Unreachable!");
	}
    }

    $$string_ref =~ s/^\s+//;
    $$string_ref =~ s/\s+$//;

    return 1;
}

sub lexer_callback ($)
{
    my $parser     = shift;
    my $help_text  = "";
    my $buffer     = "";

    assert(defined($parser));

    if ((!defined($parser->YYData->{INPUT})) ||
	($parser->YYData->{INPUT} eq "")) {
	return ('', undef);
    }

    if ($help_text_parse == 1) {

	if (!parse_help(\$parser->YYData->{INPUT}, \$help_text)) {
	    error("Failed to parse help text");
	    exit 1;
	}

	$help_text_parse = 0;
	$help_start      = 0;

	dtoken("T_HELPTEXT");
#	debug("  Passing string: \`" . $help_text . "'");

	return ('T_HELPTEXT', $help_text);
    }

    while ($parser->YYData->{INPUT} ne "") {

	my $char;

	($char) = $parser->YYData->{INPUT} =~ /^(.)/;

	if (defined($char)              &&
	    ($char =~ /[\&\|\!\=\(\)]/)) {

	    if ($buffer ne "") {
		$parser->YYData->{INPUT} = " " . $parser->YYData->{INPUT};
		next;
	    }
	}

	if ($parser->YYData->{INPUT} =~ s/^\&\&//) {
	    dtoken("T_AND");
	    return ('T_AND', '');

	} elsif ($parser->YYData->{INPUT} =~ s/^\|\|//) {
	    dtoken("T_OR");
	    return ('T_OR', '');

	} elsif ($parser->YYData->{INPUT} =~ s/^\!\=//) {
	    dtoken("T_UNEQUAL");
	    return ('T_UNEQUAL', '');

	} elsif ($parser->YYData->{INPUT} =~ s/^\!//) {
	    dtoken("T_NOT");
	    return ('T_NOT', '');

	} elsif ($parser->YYData->{INPUT} =~ s/^\=//) {
	    dtoken("T_EQUAL");
	    return ('T_EQUAL', '');

	} elsif ($parser->YYData->{INPUT} =~ s/^\)//) {
	    dtoken("T_CLOSE_PAREN");
	    return ('T_CLOSE_PAREN', '');

	} elsif ($parser->YYData->{INPUT} =~ s/^\(//) {
	    dtoken("T_OPEN_PAREN");
	    return ('T_OPEN_PAREN', '');

	} else {

	}

	$char = substr($parser->YYData->{INPUT}, 0, 1, "");

	if ($char eq "\n") {

	    if ($buffer ne "") {
		$parser->YYData->{INPUT} = $char . $parser->YYData->{INPUT};

	    } else {
		dtoken("T_EOL");

		if ($help_start == 1) {
		    $help_text_parse = 1;
		} else {
		    # Remove useless white spaces
		    $parser->YYData->{INPUT} =~ s/^[ \t]*//;
		}

		$lineno++;

		return ('T_EOL', '');
	    }
	}

	if ($char eq "#") {
	    # Handling comments

	    $parser->YYData->{INPUT} =~ s/^[^\n]*//;
	    next;
	}

	if (($char =~ /(\")/) ||
	    ($char =~ /(\')/)) {
	    my $quoted_char = $1;
	    assert(defined($quoted_char));

	    my $curr_char;
	    my $last_char;

	    $buffer = "";

	    while ($parser->YYData->{INPUT} ne "") {
		$curr_char = substr($parser->YYData->{INPUT}, 0, 1, "");

		if ($curr_char =~ /\n/) {
		    error("Multiline quoted strings are not supported");
		    return 0;
		}

		if (length($buffer) > 0) {
		    $buffer    =~ /(.)$/;
		    $last_char = $1;
		}

		if ($curr_char eq $quoted_char) {

		    if (((defined($last_char)) && ($last_char !~ /\\/)) ||
			(!defined($last_char))) {

			dtoken("T_WORD_QUOTE");
#			debug("  Passing string: \`" . $buffer . "'");

			return ('T_WORD_QUOTE', $buffer);
		    }

		}

		if (defined($buffer)) {
		    $buffer = $buffer . $curr_char;
		} else {
		    $buffer = $curr_char;
		}
	    }
	}

	if ($char =~ /[ \t\n]+/) {

	    if ($help_text_parse == 0) {
		# Remove useless white spaces
		$parser->YYData->{INPUT} =~ s/^[ \t]*//;
	    }

	    if ($buffer eq "") {
		next;
	    }

	    if ($buffer eq "def_tristate") {
		dtoken("T_DEF_TRISTATE");
		return ('T_DEF_TRISTATE', '');

	    } elsif ($buffer eq "menuconfig") {
		dtoken("T_MENUCONFIG");
		return ('T_MENUCONFIG', '');

	    } elsif (($buffer eq "def_boolean") ||
		     ($buffer eq "def_bool"))    {
		dtoken("T_DEF_BOOL");
		return ('T_DEF_BOOL', '');

	    } elsif ($buffer eq "endchoice") {
		dtoken("T_ENDCHOICE");
		return ('T_ENDCHOICE', '');

	    } elsif ($buffer eq "mainmenu") {
		dtoken("T_MAINMENU");
		return ('T_MAINMENU', '');

	    } elsif ($buffer eq "requires") {
		dtoken("T_REQUIRES");
		return ('T_REQUIRES', '');

	    } elsif ($buffer eq "optional") {
		dtoken("T_OPTIONAL");
		return ('T_OPTIONAL', '');

	    } elsif ($buffer eq "tristate") {
		dtoken("T_TRISTATE");
		return ('T_TRISTATE', '');

	    } elsif ($buffer eq "endmenu") {
		dtoken("T_ENDMENU");
		return ('T_ENDMENU', '');

	    } elsif ($buffer eq "comment") {
		dtoken("T_COMMENT");
		return ('T_COMMENT', '');

	    } elsif ($buffer eq "depends") {
		dtoken("T_DEPENDS");
		return ('T_DEPENDS', '');

	    } elsif ($buffer eq "default") {
		dtoken("T_DEFAULT");
		return ('T_DEFAULT', '');

	    } elsif ($buffer eq "select") {
		dtoken("T_SELECT");
		return ('T_SELECT', '');

	    } elsif ($buffer eq "config") {
		dtoken("T_CONFIG");
		return ('T_CONFIG', '');

	    } elsif ($buffer =~ "string") {
		dtoken("T_STRING");
		return ('T_STRING', '');

	    } elsif ($buffer =~ "choice") {
		dtoken("T_CHOICE");
		return ('T_CHOICE', '');

	    } elsif ($buffer eq "option") {
		dtoken("T_OPTION");
		return ('T_OPTION', '');

	    } elsif ($buffer eq "prompt") {
		dtoken("T_PROMPT");
		return ('T_PROMPT', '');

	    } elsif ($buffer eq "endif") {
		dtoken("T_ENDIF");
		return ('T_ENDIF', '');

	    } elsif ($buffer eq "range") {
		dtoken("T_RANGE");
		return ('T_RANGE', '');

	    } elsif ($buffer eq "menu") {
		dtoken("T_MENU");
		return ('T_MENU', '');

	    } elsif (($buffer eq "boolean") ||
		     ($buffer eq "bool"))    {
		dtoken("T_BOOL");
		return ('T_BOOL', '');

	    } elsif ($buffer eq "hex") {
		dtoken("T_HEX");
		return ('T_HEX', '');

	    } elsif ($buffer eq "int") {
		dtoken("T_INT");
		return ('T_INT', '');

	    } elsif ($buffer eq "if") {
		dtoken("T_IF");
		return ('T_IF', '');

	    } elsif ($buffer eq "on") {
		dtoken("T_ON");
		return ('T_ON', '');

	    } elsif (($buffer eq "help")        ||
		     ($buffer eq "---help---"))  {
		dtoken("T_HELP");

		$help_start = 1;
		return ('T_HELP', '');

	    } elsif ($buffer eq "---") {

		if ($parser->YYData->{INPUT} =~
		    s/^[ \t]*help[ \t]*\-\-\-//) {
		    $help_start = 1;

		    return ('T_HELP', '');
		}

		error("Undefined lexer input \`" . $buffer .
		      "' at line \`"             . $lineno .
		      "'");
		exit 1;

	    } elsif (($buffer =~ /^[\-][0-9]+$/)                  ||
		     ($buffer =~ /^([a-zA-Z0-9][a-zA-Z0-9_-]*)$/)) {
		dtoken("T_WORD");
#		debug("  Passing string: \`" . $buffer . "'");

		return ('T_WORD', $buffer);

	    } else {
		error("Undefined lexer input \`" . $buffer .
		      "' at line \`"             . $lineno .
		      "'");
		exit 1;
	    }
	}

	if (defined($buffer)) {
	    $buffer = $buffer . $char;
	} else {
	    $buffer = $char;
	}
    }

    bug("Unreacheable lexer code");
}

sub syntax_error ($$)
{
    my $message = shift;
    my $lineno  = shift;

    assert(defined($message));
    assert(defined($lineno));

    error("Syntax error at line " . $lineno . ": " . $message);
    exit 1;
}

sub error_callback ($)
{
    my $parser = shift;

    assert(defined($parser));

    my $value = $parser->YYCurtok;
    assert(defined($value));

    error("Unexpected \`" . $value . "'");
}

sub parse ($$$)
{
    my $input_filename = shift;
    my $ui_ref         = shift;
    my $set_ref        = shift;

    assert(defined($input_filename));
    assert(defined($ui_ref));
    assert(defined($set_ref));

    debug("Parsing file \`" . $input_filename . "'");

    if (!file_ispresent($input_filename)) {
	return 0;
    }

    my $string;

    $string = "";
    if (!file_tostring($input_filename, \$string)) {
	return 0;
    }

    # Parse !
    my $parser;
    $parser = Choicetool::Frontends::KConfig::Parse->new();
    assert(defined($parser));

    $parser->YYData->{INPUT}   = $string;
    $parser->YYData->{DATA}[0] = $ui_ref;
    $parser->YYData->{DATA}[1] = $set_ref;

    $parser->YYData->{DATA}[2] = Choicetool::Data::Stack->new();
    assert(defined($parser->YYData->{DATA}[2]));

    my $result;
    $result = $parser->YYParse(yylex   => \&lexer_callback,
			       yyerror => \&error_callback);

    if (($parser->YYNberr() > 0) || (!defined($result))) {
	error("Cannot parse input file \`" . $input_filename . "'");
	return 0;
    }

    debug("Parsing completed successfully");

    return 1;
}
